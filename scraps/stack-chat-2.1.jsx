<Workshop name="StackChat 2. React-Redux" description="Learn how the small but mighty React-Redux library can tie together our React components and our Redux store to make an app that's ready to scale into the big leagues!" artworkUrl="https://s3.amazonaws.com/learndotresources/workshop_artwork/1495736263613.jpeg"><Concept name="Intro"><Action name="Preparation">{"We're so close to perfection! At this point, `redux` has considerably simplified our ability to manage state by offering a single source of truth for the entire app and a friendly API for `dispatch`ing changes to that source of truth. \n\nHowever, there are still some annoyances lingering about - namely all of those container components we've written. For example, needing to use `store.subscribe` and `store.unsubscribe` all the time seems like cruft, right? We've also written `import store from ../store` so many times that my fingers are getting cramped. I suppose there are worse fates, but you know what they say - `a clean codebase is a maintainable codebase`.\n\nThey don't say that? _Well they should!_\n\nAnyway, there's an extremely helpful little library called [`react-redux`](https://github.com/reactjs/react-redux) that's going to help us clean up our code considerably! And when I say little, I mean **little**. It's actually just **one function** - a function called `connect`! However, the `connect` function is going to help us write some amazing code. \n\n* I recommend reading [this section](http://redux.js.org/docs/basics/UsageWithReact.html) of the `redux` docs to learn how to use `connect` so that you can hit the ground running. \n* Additionally, the next section of this pre-reading contains a comprehensive example of how the `connect` function works (and how it will simplify our lives). I hope that you read it as well!\n* Finally, we'll end up using a useful Redux function called `combineReducers`, which I recommend reading about [here](http://redux.js.org/docs/api/combineReducers.html)"}</Action>
<Action name="Example: Make Your Own">{"As Dan Abramov (the creator of `redux`) has stressed multiple times, the `redux` library doesn't know anything about `react`. We could use it wherever we wanted - we might use it to simplify stateful web applications built with libraries like `angular` or even `jquery`. \n\nBut since we know we want to use `react`, let's use a helper library like `react-redux` to simplify the way our stateful components communicate with the `redux` store.\n\nRight now, our \"container\" components have the following **4 jobs**:\n\n**Job 1.** Subscribe to the redux store when the component mounts.\n\n**Job 2.** Get the state from the store, and send the parts we care about down as props to our stateless components.\n\n**Job 3.** Define methods that dispatch changes to the store.\n\n**Job 4.** Unsubscribe from the redux store when the component unmounts.\n\nThe `react-redux` library gives us a method called `connect` which **simplifies the way that we perform those 4 jobs**. To learn how to use it, let's do one of my favorite things - **write it ourselves!**\n\nFor example, pretend we have the following \"container\" component:\n\n**fig. 1**\n```js\nimport React from 'react';\nimport store from '../store';\nimport { incrementCounter } from '../action-creators';\nimport StatelessComponent from './StatelessComponent';\n\nclass ContainerComponent extends React.Component {\n  constructor (props) {\n    super(props);\n    this.state = store.getState();\n  }\n\n  // Job 1: subscribe to the store\n  componentDidMount () {\n    this.unsubscribe = store.subscribe(() => this.setState(store.getState()));\n  }\n\n  // Job 4: unsubscribe when unmounting\n  componentWillUnmount () {\n    this.unsubscribe();\n  }\n\n  // Job 3: define methods that dispatch to the store\n  increment () {\n    store.dispatch(incrementCounter());\n  }\n\n  render () {\n    // Job 2: \"map\" data from the state into props\n    const {counter} = this.state;\n    return <StatelessComponent counter={counter} increment={this.increment} />\n  }\n}\n```\n\nThat's quite a lot of boilerplate. Especially the `componentDidMount` and `componentWillUnmount` hooks. Every container component we write will need that same code! Doesn't sound very DRY if you ask me.\n\nWe might solve this ourselves by writing a **function** that returns a **React component class** to handle that boilerplate. Here's what that might look like:\n\n**fig. 2a**\n```js\nimport React from 'react';\nimport store from '../store';\n\n// this function takes a class that extends React.Component as an argument...\nfunction createSubscribedComponent (OtherReactComponent) {\n  // ...and returns a new class that extends React.Component - cool!\n  return class extends React.Component {\n    constructor (props) {\n      super(props);\n      this.state = store.getState();\n    }\n\n    // Job 1: subscribe to the store\n    componentDidMount () {\n      this.unsubscribe = store.subscribe(() => this.setState(store.getState()));\n    }\n\n    // Job 4: unsubscribe when unmounting\n    componentWillUnmount () {\n      this.unsubscribe();\n    }\n\n    render () {\n      return <OtherReactComponent passedDownState={this.state} />\n    }\n  }\n}\n```\n** fig 2b**\n```js\n// Now, Job 1 and Job 4 can be entirely handled for us!\n// This means now we only need to write a component to do Job 2 and Job 3!\nimport React from 'react';\nimport store from '../store';\nimport { incrementCounter } from '../action-creators';\n\nclass ContainerComponent extends React.Component {\n\n  // Job 3: define methods that dispatch to the store\n  increment () {\n    store.dispatch(incrementCounter());\n  }\n\n  render () {\n    // Job 2: \"map\" data from the state into props\n    const {counter} = this.props.passedDownState;\n    return <StatelessComponent counter={counter} increment={this.increment} />\n  }\n}\n\n```\n** fig 2c**\n```js\n// Now, we can create arbitrary components that subscribe and unsubscribe from the store.\n// Just like this:\n\nconst SubscribedComponent = createSubscribedComponent(ContainerComponent);\n```\n\nCool, so now we have a function that that will automate all of the `componentDidMount` and `componentWillUnmount` boilerplate, so we can just focus on writing components that map out state and map out functions that use dispatch. \n\nThis is great...but we can do even better! Do we *really* need to write extra components to map out state and methods? We don't! Instead, we could just write **functions** that do Jobs 2 and 3 for us, and then teach the SubscribedComponent how to invoke them.\n\nThis is where it gets tricky, but don't worry - you may need to return to this point and re-read a couple of times before it clicks, and that's okay! Here we go:\n\nWe want to bake the ability to perform Jobs 2 and 3 into the component that `createSubscribedComponent` returns. We can do this by wrapping `createSubscribedComponent` in *another* function. This is the function that we're going to call `connect`.\n\n`connect` is a function that returns a function (a.k.a a \"higher-order function\"). It returns our `createSubscribedComponent` function from before (with a few changes). `connect` takes two arguments, \"functionThatDoesJob2\", and \"functionThatDoesJob3\". We will write these functions ourselves every time we have a new component to create. We'll write them for our example in a moment but for now, assume the following:\n* `functionThatDoesJob2` takes the redux store's state as an argument, and returns an *object* with just the props we want to pass as its key-value pairs.\n* `functionThatDoesJob3` takes the redux store's `dispatch` method as an argument, and returns an *object* with all of the specific methods we want as key-value pairs.\n\n**fig 3a**\n```js\nimport React from 'react';\nimport store from '../store';\n\nfunction connect (functionThatDoesJob2, functionThatDoesJob3) {\n  // createSubscribedComponent will have closure over functionThatDoesJob2 and functionThatDoesJob3\n  return function createSubscribedComponent (OtherReactComponent) {\n    return class extends React.Component {\n      constructor (props) {\n        super(props);\n        this.state = store.getState();\n      }\n\n      // Job 1: subscribe to the store\n      componentDidMount () {\n        this.unsubscribe = store.subscribe(() => this.setState(store.getState()));\n      }\n\n      // Job 4: unsubscribe when unmounting\n      componentWillUnmount () {\n        this.unsubscribe();\n      }\n\n      render () {\n        // Job 2: ourProps is an object that looks like this: \n        // { counter: state.counter }\n        const ourProps = functionThatDoesJob2(store.getState());\n\n        // Job 3: ourMethods is an object that looks like this: \n        // { increment: function () { dispatch(incrementCounter()) } }\n        const ourMethods = functionThatDoesJob3(store.dispatch)\n\n        // all of our props and methods get passed down to the OtherReactComponent!\n        return <OtherReactComponent {...ourProps} {...ourMethods} />\n      }\n    }\n  }\n}\n```\n\nWith the above in mind, here's how we might write `functionThatDoesJob2` and `functionThatDoesJob3`:\n\n**fig 3b**\n```js\nimport React from 'react';\nimport { incrementCounter } from '../action-creators';\n\n// expects to receive the current state as an argument\n// returns an object literal with just the fields from state we care about\nfunction functionThatDoesJob2 (state) {\n  return {\n    counter: state.counter\n  };\n}\n\n// expects to receive the dispatch method as an argument\n// returns an object literal with the methods we want to use\nfunction functionThatDoesJob3 (dispatch) {\n  return {\n    increment: function () {\n      dispatch(incrementCounter());\n    }\n  };\n}\n```\n\nNow, if we put this all together, we no longer need to write our own React.Component classes that subscribe/unsubscribe from the store **or** pass down props and methods. All we need to do is write those two functions above!\n\n**fig 3c**\n```js\n// We pass in the two functions we wrote above to \"connect\" and invoke it,\n// which gives us our \"createSubscribedComponent\" function, which now has closure over the\n// two functions, and we invoke that with our target component!\nconst CompletedCounterComponent = connect(\n  functionThatDoesJob2, functionThatDoesJob3)(StatelessComponent);\n// We can pass our StatelessComponent right in to receive the props it needs! \n// No need to write a new class!\n```\n\nNow, **any time** we want a component that's hooked up to the redux store, we don't need to write a class - we just need to write a couple of functions! Compare that with all of the cruft from **fig 1**. How cool is that?\n\nAnd this is _basically all that the `connect` method that we import from the `react-redux` library does!_ The official `connect` method is slightly more sophisticated than the one we've written here, but not by much! \n\nLastly, in official `react-redux` parlance, the two functions we wrote (`functionThatDoesJob2` and `functionThatDoesJob3`) are commonly referred to as `mapStateToProps` and `mapDispatchToProps`. You'll probably want to call them that going forward :)\n\nIt's okay if the above doesn't totally click at first - while it might not be much code, it takes advantage of some fairly complex fundamental concepts like `closure` and `function composition`. It may not even totally click until you start to use `connect` yourself, which is also okay! We'll be doing quite a lot of that in the workshop very shortly!"}</Action>
<Action name="Goal">{"For this workshop, we will be introducing the `react-redux` library to replace the boilerplate for subscribing our components to the store with `connect` components.\n\nWe'll do lots of refactoring of old code to practice, but first - we'll write our first `connect` component by implementing some new features.\n\nWe've added a new Route that renders a component for adding new channels:\n\n<h5>Starting Point</h5>\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/591c4d7633a48d0004c39898/reactredux-start.png\" />\n\nWe have three main tasks:\n\n1. Channels should no longer be hardcoded we'll fetch them from the server\n2. Allow a user to create a new channel\n3. **Bonus**: The selected channel name should display in the top nav\n\n<h5>Goals 1 and 2</h5>\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/591c4d7633a48d0004c39898/reactredux1-1.png\" />\n\n<h5>Goal 3 (Bonus)</h5>\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/591c4d7633a48d0004c39898/reactredux2.png\" />"}</Action>
<Action name="Starting Point">{"## Install StackChat 2 Start\n\nIf you have not yet forked https://github.com/FullstackAcademy/stackchat, then please do so now.\n\nClone it again into a new repo like so: `git clone https://github.com/<your-github-username>/stackchat --branch day2-starting`, and then `npm install` (or `yarn install`) again. This will set up a new repo with the day 2 starting code.\n\nWe recommend that you branch off from this starting point branch (for example, you could create and checkout a new branch called \"day2\" by typing: `git checkout -b day2`) and work off from that branch instead of \"master\"."}</Action></Concept>
<Concept name="Provider"><Action name="Install">{"To get started with `react-redux`, we of course need to install it:\n\n`npm install --save react-redux`\n\n<guide>\nYou have installed react-redux\n</guide>"}</Action>
<Action name="Plugging In">{"Remember how I said `connect` is the only thing that the `react-redux` library gives us? I sort of lied. There is _one more thing_ that `react-redux` gives us, but it's just a bit of boilerplate code to make our lives easier.\n\nThis boilerplate code is a component called `Provider`. It goes at the _very top_ of our component hierarchy and accepts our `store` as a prop. All it does is it puts the `store` onto a _slightly magical_ React thing called [context](https://facebook.github.io/react/docs/context.html). Here's what it looks like:\n\n```js\nimport { Provider } from 'react-redux';\nimport store from './store';\n\nReactDOM.render(\n  <Provider store={store}>\n    <Router>\n      <Main />\n    </Router>\n  </Provider>,\n  document.getElementById('app')\n);\n```\n\n`Context` is essentially like a [global variable](https://learndotresources.s3.amazonaws.com/workshop/58135430b659df00039f518f/global_variables.png) for our React app, which will make the store available in all of our child components as `this.context.store`. \n\n*I know, I know*, **I know** - here's the thing though: the `connect` method needs the store to work, so if it doesn't find it on context, then it's going to need it passed as a prop every time we use `connect`. And that's fine, but it's also a pain. We've done a lot of typing, so we deserve a little magic.\n\n**NOTE:** The `connect` method is allowed to grab the store from context, but I strongly urge you not to do this yourself. If you find yourself accessing the store from context yourself, you are probably doing something wrong - we'll see that `react-redux` gives us an interface to the store via `mapStateToProps`.\n\n**NOTE 2:** Seriously, don't try to use context in any other way than this. This is the only time you're allowed to use context. Ever.\n\n<guide>\nYou have read and understood the above\nYou have acknowledged the evils of global variables, but are okay with just this once and never again\n</guide>"}</Action>
<Action name="Provide It">{"Go ahead and plug the store into the Provider in your `client/index.js` - *just this once, and we won't worry about it again*.\n\n<guide>\nYou have imported and set up the Provider component properly at the root of your app\nYou have sworn to never use global variables again but for this one time\n</guide>"}</Action></Concept>
<Concept name="Connect"><Action name="Codebase">{"With that little bit of unpleasantness behind us, let's get to the goods!\n\nFirst, let's re-familiarize ourselves with the codebase - it may be a bit different than what you ended up with yesterday. In particular, check out:\n\n1. `Main.js` - a new Route has been added here to render the new channel entry view. Also note that we are now using the `componentDidMount` hook in `Main.js` to fetch all of our messages, rather than the one in `MessagesList.js`. This is because we always want to update the message counter next to each channel name in the sidebar whenever the app loads. If we only fetched all messages when `MessagesList` loaded, we would not have them if we refreshed the page while looking at the \"new-channel\" Route.\n2. `NewChannelEntry.js` - this is our form for entering new channels\n3. `ChannelList.js` - this is our hardcoded list of channels that we're going to replace\n4. `store.js` - make sure that you remember how the store is organized\n5. `server/socket.js` - a new listener has been added for channels! We'll want this later!\n\n<guide>\nYou have reviewed at least the components above\n</guide>"}</Action>
<Action name="Channels">{"Let's get started by replacing the hardcoded channels in our `ChannelList` with real channels from the server. If you request http://localhost:8080/api/channels, you should receive a JSON list of channels from the server (they match the ones that we've hardcoded in). \n\nIf we want them to show up in our view, we need to store them on our state (just like messages). Let's start out by making room for channels in our Redux store! This will be a great review of all of the concepts we learned yesterday. In `store.js`:\n\n* Add an `action type` to represent getting channels from the server\n* Add a field to our `initialState` to represent our list of channels\n* Add an `action creator` that creates an action for receiving our channels from the server\n* Add a case to our `reducer` that updates our state with the list of channels we get when we dispatch our action\n* Finally, add a `thunk creator` that creates a thunk to perform the AJAX request that fetches our channels from the server. The thunk should eventually dispatch our synchronous channel action to the store\n\nFor reference, look at the way we currently fetch our list of messages from the server and add them to our store - channels will be very similar.\n\n<hint title=\"Solution\">\nYou'll eventually end up adding code like this:\n\n<pre>\n// action type\nconst GET_CHANNELS = 'GET_CHANNELS';\n\n// action creator\nfunction getChannels (channels) {\n  return {\n    type: GET_CHANNELS,\n    channels: channels\n  };\n}\n\n// thunk creator\nfunction fetchChannels () {\n  return function (dispatch) {\n    axios.get('/api/channels')\n      .then(res => res.data)\n      .then(channels => dispatch(getChannels(channels)));\n  }\n}\n\n// initialState\nconst initialState = {\n  messages: [],\n  name: '',\n  newMessageEntry: '',\n  channels: []\n}\n\n// reducer\nfunction reducer (state = initialState, action) {\n  // etc...\n\n  case GET_CHANNELS:\n    return { ...state, channels: action.channels };\n\n  // etc...\n}\n</pre>\n</hint>\n\n<guide>\nYou have completed the steps above\n</guide>"}</Action>
<Action name="Loading Channels">{"First, let's get our list of channels from the server (right now, we're still using hardcoded data).\n\n<ol>\n\n<li> Open `Main.js` </li>\n<li> Import your \"fetch channels\" thunk creator </li>\n<li> In the `componentDidMount` of the `Main` component, dispatch a thunk for fetching the channels (this is in addition to dispatching the thunk to get messages that's already there). It's totally fine to dispatch the thunks separately - it doesn't matter who gets there first </li>\n\n<hint title=\"Solution\">\nYour `componentDidMount` should look something like this:\n```js\n  componentDidMount () {\n    const messagesThunk = fetchMessages();\n    const channelsThunk = fetchChannels();\n    store.dispatch(messagesThunk);\n    store.dispatch(channelsThunk);\n  }\n```\n</hint>\n\n<br/>\nAt this point, whenever your app loads, you'll fetch all of the messages *and* channels and put them in the store. Now that the channels are in the store, we can use them!\n\n</ol>\n\n<guide>\nYou have completed the steps above\n</guide>"}</Action>
<Action name="A Connection">{"The moment of truth is at hand! Get ready to write your first `connect` component using `react-redux`. If you haven't had the chance yet, read [this page of the redux docs](http://redux.js.org/docs/basics/UsageWithReact.html) to familiarize yourself with how `connect` works. I'll walk you through this first one step by step.\n\n<ol>\n\n<li> Open `ChannelList.js`</li>\n<br/>\n<li> Remove all of the `store.subscribe` boilerplate - we're going to replace it with `connect`. You can even re-write the component as a function! Get rid of all that hardcoded data as well - we're going to replace it with REAL data from the store! </li>\n<br/>\n<hint title=\"Possible starting point\">\n\nWe could re-write the ChannelList component to look like this:\n\n<pre>\nfunction ChannelList (props) {\n  return (\n    &lt;ul>\n      &lt;li>\n        &lt;NavLink to={\"URL_GOES_HERE\"} activeClassName=\"active\">\n          &lt;span># {/* channel name goes here */}&lt;/span>\n          &lt;span className=\"badge\">{/* number of messages calculation goes here */}&lt;/span>\n        &lt;/NavLink>\n      &lt;/li>\n      &lt;li>\n        &lt;NavLink to=\"/new-channel\">Create a channel...&lt;/NavLink>\n      &lt;/li>\n    &lt;/ul>\n  );\n}\n</pre>\n</hint>\n<br/>\n<li> Import `connect` from `react-redux` (remember, it's **not** a default export).</li>\n<br/>\n<li> Write a function called `mapStateToProps`. It should expect to receive `state` as its first argument, and return an empty object (we'll fill it in later).</li>\n<br/>\n<hint title=\"Solution\">\n```js\nconst mapStateToProps = function (state) {\n  return {};\n};\n```\n</hint>\n<br/>\n<li> Pass `mapStateToProps` to `connect`. This will return another function - pass the `ChannelList` component to that function. Store the result in a variable called `ChannelListContainer` </li>\n<br/>\n<hint title=\"Solution\">\nDouble functions, whoa!\n```js\nconst ChannelListContainer = connect(mapStateToProps)(ChannelList);\n```\n</hint>\n<br/>\nWhat just happened? To get a full understanding, check out the [Example](https://learn.fullstackacademy.com/workshop/591c4d7633a48d0004c39898/content/591c4d7733a48d0004c398a4/text) - but in short, we've wrapped our \"dumb\" ChannelList component in a \"smart\" component that's connected to the store! All we need to do now is decide what values we want to get from the store (using the `mapStateToProps` function that we wrote), and we'll be guaranteed to re-render the component with them every time they change!\n<br/><br/>\n<li> Export the `ChannelListContainer` by default (you may need to remove the `export default` from the original `ChannelList` </li>\n<br/>\n</ol>\n\nNow, when we render `<ChannelList />` from another component, we're *actually* rendering the smart container, which in turn renders the \"dumb\" component! Before things work the way they did before though, we need to complete a few more steps - move on to the next section and we'll wrap things up!\n\n<guide>\nYou have completed the steps above\n</guide>"}</Action>
<Action name="Map State">{"Now that `ChannelList` is connected, let's see what it means to \"map state to props\".\n\n1. Map the channels field on state to a prop that we give to `ChannelList`\n<br/><br/>\n<hint title=\"Solution\">\n```js\nconst mapStateToProps = function (state) {\n  return {\n    channels: state.channels\n  };\n};\n```\n</hint>\n<br/>\n2. Map the messages field on state to a prop that we give to `ChannelList`\n<br/><br/>\n<hint title=\"Solution\">\n```js\nconst mapStateToProps = function (state) {\n  return {\n    channels: state.channels,\n    messages: state.messages\n  };\n};\n```\n</hint>\n<br/>\nNow, our `ChannelList` component will be re-rendered with the channels and messages values from our state whenever either of them change. This means we can use them to calculate the view!\n<br/><br/>\n3. In the `ChannelList` dumb component, use the channels array (available on props) to map out a list of `<li>` elements to match what we had before.\n<br/><br/>\n<hint title=\"Solution\">\nIn the ChannelList component:\n\n<pre>\nfunction ChannelList (props) {\n  return (\n    &lt;ul>\n      {\n        props.channels.map(channel => {\n          return (\n            &lt;li key={channel.id}>\n              &lt;NavLink to={`/channels/${channel.id}`} activeClassName=\"active\">\n                &lt;span># {channel.name}&lt;/span>\n                &lt;span className=\"badge\">{/* number of messages calculation goes here */}&lt;/span>\n              &lt;/NavLink>\n             &lt;/li>\n          )\n        })\n      }\n      &lt;li>\n        &lt;NavLink to=\"/new-channel\">Create a channel...&lt;/NavLink>\n      &lt;/li>\n    &lt;/ul>\n  );\n}\n</pre>\n\n</hint>\n<br/>\n4. In the `ChannelList` dumb component, use the messages array (available on props) to re-implement the message counter next to each channel.\n<br/><br/>\n<hint title=\"Solution\">\nIn the ChannelList component:\n\n<pre>\nfunction ChannelList (props) {\n  return (\n    &lt;ul>\n      {\n        props.channels.map(channel => {\n          return (\n            &lt;li key={channel.id}>\n              &lt;NavLink to={`/channels/${channel.id}`} activeClassName=\"active\">\n                &lt;span># {channel.name}&lt;/span>\n                &lt;span className=\"badge\">{props.messages.filter(message => message.channelId === channel.id).length}&lt;/span>\n              &lt;/NavLink>\n             &lt;/li>\n          )\n        })\n      }\n      &lt;li>\n        &lt;NavLink to=\"/new-channel\">Create a channel...&lt;/NavLink>\n      &lt;/li>\n    &lt;/ul>\n  );\n}\n</pre>\n\n</hint>\n\n**Try it out!** The channels should appear again, and adding new messages should update the counter for that channel!\n\n<p style=\"color:red;font-weight:bold\">Wait up! Something's broken!</p> You might notice that channels in the sidebar no longer switch to their `activeClassName` when you select them - that stinks! We'll learn why this is happening and fix it shortly - move on in the meantime.\n\n<guide>\nEverything should work they way it did when we started (except for the bug mentioned above). Only now, we're using real data!\n</guide>"}</Action></Concept>
<Concept name="Adding New Channels"><Action name="Goal">{"So far, we've written a new container that uses a `mapStateToProps` function to get our list of channels and messages from state, and passes them down to our presentational component.\n\nNext, we'll dive into the marshmallow center of the workshop - adding new channels - and see how we can pass down behavior as well using `connect`'s second argument, `mapDispatchToProps`.\n\n<guide>\nYou have read and understood the above\n</guide>"}</Action>
<Action name="Channel Entry">{"Our goal is to fill out a form with a channel's name and submit it to post a new channel. We should model this behavior out in Redux (in `store.js`) before we worry about our view components. \n\nBy now, this should start to feel familiar - feel free to give it a shot on your own! The process will be very similar to posting new messages, so you can use that code as a reference. If you want some more guidance, open the hint below - it will advise you on the different ingredients you need to make.\n\n<hint title=\"Guidebook\">\n* Add a field to state for the value of the channel entry input field\n* Write an action type and an action creator for writing a channel name into the input\n* Write an action type and an action creator for receiving a new channel from the server\n* Add cases to your reducer for handling the two actions above\n* Write a thunk that will post a new channel to the server, and then dispatch the action for adding a new channel to our array of channels. To post a new channel on the server, we need a request body that includes the `name` of the new channel\n</hint>\n<br/>\n<hint title=\"Solution\">\nYou will likely end up with new code like this in your `store.js`:\n\n```js\n// action types\nconst WRITE_CHANNEL_NAME = 'WRITE_CHANNEL_NAME';\nconst GET_CHANNEL = 'GET_CHANNEL';\n\n// action creators\nexport function writeChannelName (channelName) {\n  const action = { type: WRITE_CHANNEL_NAME, channelName };\n  return action;\n}\n\nexport function getChannel (channel) {\n  const action = { type: GET_CHANNEL, channel };\n  return action;\n}\n\n// thunk creator\nexport function postChannel (channel) { // expecting channel to an object like: { name: 'new_channel_name' }\n\n  return function thunk (dispatch) {\n    return axios.post('/api/channels', channel)\n      .then(function (res) { return res.data })\n      .then(function (newChannel) {\n        dispatch(getChannel(newChannel));\n      });\n  };\n}\n\nfunction reducer (state = initialState, action) {\n  // etc...\n    case WRITE_CHANNEL_NAME:\n      return {\n        ...state,\n        newChannelEntry: action.channelName\n      };\n\n    case GET_CHANNEL:\n      return {\n        ...state,\n        channels: [...state.channels, action.channel]\n      };\n\n  // etc...\n}\n\n```\n</hint>\n\n<guide>\nYou have added the necessary functionality to `store.js`\n</guide>"}</Action>
<Action name="Defining Methods With mapDispatchToProps">{"Now that we can handle adding a new channel with Redux, let's get down to connecting our component!\n\nWhen you open `NewChannelEntry.js`, you'll notice that it is a clean, \"dumb\", functional component. Part of our goal in using `connect` is to keep it that way. In fact, let's keep two goals in mind:\n\n**1. Maximize the number of functional components in our code (they are the easiest to understand, and the most re-usable)**\n\n**2. Minimize the number of times we directly import and use the store**\n\nThat first point should be pretty familiar (think Tom's Second Law)! The second point may be a little strange though - we've been directly using `store.dispatch` a lot. However, now that we have `connect`, we can avoid using the `store` directly most of the time. This is a good rule to follow, because it enforces a stricter `separation of concerns` that will make our code easier to navigate. Think of it this way - instead of dirtying our hands by using the store, we delegate that responsibility to connect.\n\n*\"But wait\"*, you ask - *\"how are we supposed to dispatch actions from our components without writing methods on them?\"*\n\nI'm so glad you asked - the answer is to use `mapDispatchToProps`!\n\n`mapDispatchToProps` is the second argument we pass to `connect`. Just like `mapStateToProps`, it's a function that returns an object, and any key-value pairs on that object will become available as props on the connected component.\n\nHowever, *unlike* `mapStateToProps`, a `mapDispatchToProps` function receives the `dispatch` method as the first argument, rather than `state`. We can use the dispatch method here to implement our methods (like click/submit/change handlers)!\n\n**Example:**\n\n```js\n// receives dispatch as an argument\nconst mapDispatchToProps = function (dispatch) {\n  return {\n    someMethod: function () {\n      dispatch(someActionCreator())\n    };\n  };\n}\n\n// receives state as an argument\nconst mapStateToProps = function (state) {\n  return {\n    someStuff: state.someStuff\n  }\n}\n\n// receives the props that mapStateToProps and mapDispatchToProps define\nfunction SomeComponent (props) {\n  return (\n    <div>\n      <h5>{ props.someStuff }</h5> {/* props.someStuff comes from mapStateToProps */}\n      <button onClick={props.someMethod}>Click Me</button> {/* props.someMethod comes from mapDispatchToProps */}\n    </div>\n  )\n}\n\nconst SomeContainer = connect(mapStateToProps, mapDispatchToProps)(SomeComponent);\n```\n\n<guide>\nYou have read and understood the above\n</guide>"}</Action>
<Action name="Control Input">{"Let's start connecting `NewChannelEntry`!\n\n<ol>\n<li> Import `connect` into `NewChannelEntry.js`</li>\n<br/>\n<li> Write `mapStateToProps` and `mapDispatchToProps` functions (return empty objects for now). Pass these to `connect`, and then pass in the NewChannelEntry component to create the container. Export the container by default.</li>\n<br/>\n<hint title=\"Solution\">\n```js\nconst mapStateToProps = function (state) {\n  return {};\n};\nconst mapDispatchToProps = function (dispatch) {\n  return {};\n};\n\nconst Container = connect(mapStateToProps, mapDispatchToProps)(NewChannelEntry);\nexport default Container;\n```\n</hint>\n\n<br/>\nNow that we're set up, let's map some state to props.\n\n<li> Map the value of the channel input from our state to be a prop for the `NewChannelEntry` component </li>\n<br/>\n<hint title=\"Solution\">\n```js\nconst mapStateToProps = function (state) {\n  return {\n    newChannelEntry: state.newChannelEntry\n  };\n};\n```\n</hint>\n<br/>\n<li> Pass the input value from state in as the `value` prop for the `<input>` element in the component. Remember that this makes our `<input>` a \"controlled\" component. </li>\n<br/>\n</ol>\n<hint title=\"Solution\">\n<pre>\n&lt;input\n  value={props.newChannelEntry}\n  className=\"form-control\"\n  type=\"text\"\n  name=\"name\"\n  placeholder=\"Enter channel name\"\n/>\n</pre>\n</hint>\n\n<guide>\nYou have completed the steps above\n</guide>"}</Action>
<Action name="Handling Change">{"Now let's work up the behavior that we'll pass to the component.\n\n<ol>\n<li> In the object your `mapDispatchToProps` function returns, write a \"handleChange\" function. This should accept an \"event\", and dispatch an action to update the input value in the store </li>\n</br>\n<hint title=\"Solution\">\n```js\nimport { writeChannelName } from '../store';\n\nconst mapDispatchToProps = function (dispatch, ownProps) {\n  return {\n    handleChange (evt) {\n      dispatch(writeChannelName(evt.target.value));\n    }\n  };\n};\n```\n</hint>\n<br/>\n<li>Pass your change handler to the change listener on the `<input>`</li>\n<br/>\n\n<hint title=\"Solution\">\n<pre>\n&lt;input\n  value={props.newChannelEntry}\n  onChange={props.handleChange}\n  className=\"form-control\"\n  type=\"text\"\n  name=\"name\"\n  placeholder=\"Enter channel name\"\n/>\n</pre>\n</hint>\n\n<br/>\nWhen you're done, typing into the input field should update the value in the store!\n\n<guide>\nYou have completed the steps above\n</guide>"}</Action>
<Action name="Submitting a Channel">{"All right - we're very close now. \n\n<ol>\n\n<li> In your `mapDispatchToProps`, write a submit handler function that you can pass down to the component. It should expect the event object as an argument, and should dispatch our `postChannel` thunk. We have two options for getting the value of the form input - we could use the value that we've stored on state, or we could \"cheat\" a little bit and grab the value off of the event, which may be quicker for now. Remember that for submit events, you can find the value of any form input by its name on `event.target` (for example, in this case we could find the current value of the input on `event.target.channelName.value`, because our `<input>` in the form has `name=\"channelName\"`. </li>\n\n<br/>\n\n<hint title=\"Solution\">\nHere's how we would grab the value off of the event:\n\n```js\nimport { writeChannelName, postChannel } from '../store';\n\nconst mapDispatchToProps = function (dispatch, ownProps) {\n  return {\n    handleChange (evt) {\n      dispatch(writeChannelName(evt.target.value));\n    },\n    handleSubmit (evt) {\n      evt.preventDefault();\n      const name = evt.target.channelName.value;\n      dispatch(postChannel({ name }));  // this is ES6 object destructuring! It's equivalent to { name: name }\n    }\n  };\n};\n```\n</hint>\n\n<br/>\n\n<li> Attach the submit handler to the `<form>` element. </li>\n\n<br/>\n\n<hint title=\"Solution\">\n<pre>\n&lt;form onSubmit={props.handleSubmit}>\n</pre>\n</hint>\n\n<br/>\n\n**Try it out** - you should see the new channel get added. That being said, it'd be no fun to just chat on this new channel ourselves. Let's make sure to emit this new channel across sockets so that other clients get the new channel as well!\n\n<br/>\n<br/>\n\n<li> After we've created the new channel, we want to emit a `'new-channel'` event. This will be very similar to what we've done for new messages. </li>\n\n<br/>\n\n<hint title=\"Solution\">\n<pre>\nexport function postChannel (channel) {\n\n  return function thunk (dispatch) {\n    return axios.post('/api/channels', channel)\n      .then(res => res.data)\n      .then(newChannel => {\n        dispatch(getChannel(newChannel));\n        socket.emit('new-channel', newChannel);\n      });\n  };\n}\n</pre>\n</hint>\n\n<br/>\n\n<li> If you check out `server/socket/index.js`, you'll notice that we're already listening for the `'new-channel'` event, and emitting one back to all other clients. This means that all we need to do now is listen for that event from the client, and update our state with the new channel. Once again, this should be quite familiar. </li>\n\n<br/>\n\n<hint title=\"Solution\">\nIn `client/socket.js`:\n<pre>\n  socket.on('new-channel', channel => {\n    store.dispatch(getChannel(channel));\n  });\n</pre>\n</hint>\n\n</ol>\n\n**Try it out again!** Use your partner's machine or another browser tab to test. Now we're rolling in real time!\n\nThere are two more improvements we can make, though:\n\n* It would be nice if the field cleared out its value when we submitted...this is an optional exercise for you\n* When we create a new channel, it would be really nice to instantly navigate to that new channel. We will do this together in the next section\n\n<guide>\nYou can create new channels, and these new channels appear across sockets\n</guide>"}</Action>
<Action name="OwnProps">{"Before we go any further, let's take a moment to learn about the **second** argument that `connect` passes to both `mapStateToProps` and `mapDispatchToProps`. It's called `ownProps`.\n\nIn addition to `state` as its first parameter, `mapStateToProps` functions can also expect to receive an object called `ownProps` in the second parameter.\n\n```js\nfunction mapStateToProps = function (state, ownProps) {\n  return {\n    // etc...\n  };\n}\n```\n\nLikewise, `mapDispatchToProps` receives the **same** thing.\n```js\nfunction mapDispatchToProps = function (dispatch, ownProps) {\n  return {\n    // etc...\n  };\n}\n```\n\nThis is so that container components can accept props of their own (for example, from other components we write, or from `react-router` if a container is mounted under a `Route`).\n\nConsider this example:\n\n```js\nimport FoodListContainer from '../containers/FoodListContainer';\n\nexport default function MyFavoriteFoods (props) {\n\n  // [\"bagels\", \"chocolate\", \"key lime pie\"]\n  // ...in case anyone was wondering\n  const myFavoriteFoods = props.myFavoriteFoods;\n\n  return (\n    <div>\n      <h3>Blah Blah Blah</h3>\n      <FoodListContainer favorites={myFavoriteFoods} />\n    </div>\n  );\n}\n```\n\nNow, if `FoodListContainer` is a `connect` component, we will have access to \"myFavoriteFoods\" as `ownProps.favorites`:\n\n```js\nconst mapStateToProps = function (state, ownProps) {\n  return {\n    favorites: ownProps.favorites, // [\"bagels\", \"chocolate\", \"key lime pie\"]\n    hasHealthyDiet: ownProps.favorites.indexOf(\"broccoli\") !== -1 // false :(\n  };\n}\n\nconst mapDispatchToProps = function (dispatch, ownProps) {\n  return {\n    changeDiet: function () {\n      dispatch(changeDietActionCreator(ownProps.favorites))\n    }\n  };\n}\n```\n\nSound good? Then onward!\n\n<guide>\nYou have read and understood the above\n</guide>"}</Action>
<Action name="Dynamic Routing">{"Now, where were we? Oh yes - when we create a new channel, we want to dynamically navigate to that new channel. To do this, we'll learn a little bit more about React Router's [`history`](https://reacttraining.com/react-router/web/api/history) prop.\n\nIn addition to `match` and `location`, `history` is one of the three props that every `Route` passes to its `component`. The `history` object is mutable (so use it with care)! We need it here though, because it supports a method (`history.push('pathname')`), which will allow us to dynamically change the value in the URL bar such that everything in our router will re-render.\n\n**Example**:\n\n* If we say `history.push('/new-channel')`, then the url will change to `http://localhost:8080/new-channel`, and the new channel component will be re-rendered.\n\n* If we say `history.push('/channels/1')`, then the url will change to `http://localhost:8080/channels/1`, and the messages list component will be re-rendered.\n\nWith this in mind:\n\n* In your `NewChannelEntry`, obtain the `history` prop that the `Route` sends to you\n* Use the `history.push` method to update the url *after* the new channel is created\n\n**Note:** when you're done, it may be difficult to tell that it worked because of our `activeClassName` bug! To test it out, send a message to your new channel and make sure that the proper message counter increments!\n\n<hint title=\"Where is the history object?\">\nRemember `ownProps` is the second argument to `mapDispatchToProps` and `mapStateToProps`. You'll find it there! \n</hint>\n\n<hint title=\"More hints\">\nThunk creators can take any number of arguments - why not pass `history` along so that you can use it after the channel is created?\n</hint>\n\n<hint title=\"Solution\">\nYou submit handler may change like so. We'll pass down the history object as an additional argument to postChannel:\n\n```js\n    handleSubmit (name, evt) {\n      evt.preventDefault();\n      dispatch(postChannel({ name }, ownProps.history));\n      dispatch(writeChannelName(''));\n    }\n```\n\nAnd your postChannel thunk creator may be modified to do this, so that it uses history.push after the promise resolves:\n\n<pre>\nexport function postChannel (channel, history) {\n\n  return function thunk (dispatch) {\n    return axios.post('/api/channels', channel)\n      .then(res => res.data)\n      .then(newChannel => {\n        dispatch(getChannel(newChannel));\n        socket.emit('new-channel', newChannel);\n        history.push(`/channels/${newChannel.id}`);\n      });\n  };\n}\n</pre>\n</hint>\n\n<guide>\nSubmitting a new channel switched you to that new channel\n</guide>"}</Action></Concept>
<Concept name="Optimizations"><Action name="Goal">{"So far so good! We can create new channels, which update across clients! We still have two outstanding issues to resolve:\n\n* Fixing our `activeClassName` bug\n* Showing the channel name in the header\n\nFor this next section, we'll focus on fixing the `activeClassName` bug, and clean up the code in `store.js` by using an extremely helpful `redux` utility called `combineReducers`.\n\n<guide>\nYou have read the above\n</guide>"}</Action>
<Action name="A Word on shouldComponentUpdate">{"If you've been reading the React and/or Redux docs, you may have come across a lifecycle hook called [`shouldComponentUpdate`](https://facebook.github.io/react/docs/optimizing-performance.html#avoid-reconciliation), which can yield some massive performance wins for React.\n\nThe doc linked to above goes into some great detail about how it works, so I won't cover it too much myself, but the gist is that React components have a lifecycle hook called `shouldComponentUpdate`, which receives the `nextProps` and `nextState` that are passed down to a component when it's about to re-render. If `shouldComponentUpdate` is defined, it will be evaluated before that component re-renders, and if `shouldComponentUpdate` returns `false`, the rendering will be canceled!\n\nThis could yield huge benefits. Consider the following (common) situation:\n```js\n    <SharedStateContainer> // state has three fields: { foo, bar, quux }\n    /                    \\\n<ComponentA>          <ComponentB>\n// needs foo and bar   // needs foo and quux\n```\n\nIf we change the value of `foo` in the SharedStateContainer, then we of course want to re-render both ComponentA and ComponentB. But what if we change the value of `bar`? We need ComponentA to re-render, but why should ComponentB have to re-render as well? It shouldn't!\n\n`shouldComponentUpdate` can compare the current props that ComponentB has, and the nextProps that it will receive when SharedStateContainer re-renders. If we only changed `bar` in our parent's state, then ComponentB would be able to tell that `props.foo === nextProps.foo` `&&` `props.quux === nextProps.quux`, and return `false` in its `shouldComponentUpdate`. Then ComponentB's rendering (as well as the rendering of any of its own children) would be canceled.\n\nThis may not seem like much in an example with only a handful of components, but imagine that ComponentA and ComponentB have **hundreds** of child components. You can imagine how much your browser would thank you to not have to re-paint all of them every time!\n\n\nOkay, are you ready for the best part? **The `connect` method implements `shouldComponentUpdate` for you**. As long as you use `connect`, you get a huge performance boost just for showing up!\n\nGo ahead and high five your partner - that's pretty cool, right?\n\nAll that you need to do (and this is something you've already been doing) is make sure that your state is **immutable** - updates to arrays should always perform immutable operations like `concat`, `map` and `filter` (but **never** `push` or `pop`), and updates to objects should always use `Object.assign` with a fresh object literal as the first argument.\n\nIf you don't, then this same functionality will bite you. Remember that objects and arrays in JavaScript represent a location in memory, and when you evaluate equality for an object or an array, the `===` operator is actually checking to see if the object or array is referring to the same location in memory, *not* whether their contents are the same.\n\n```js\nconst array = [];\nconst sameArray = array;\nsameArray.push(1);\n\narray === sameArray; // true! The same array is referenced by both variables!\n\nconst differentArray = array.slice();\narray === differentArray // false! Array.prototype.slice always returns a new array!\n```\n\nThis means that if you *mutate* an object or array on your state, your `connect` components will think that nothing has changed (because the address of your current object will be equal to the address of the next object), and they'll prevent your components from re-rendering even though they should!\n\nMoral of the story - don't forget to always treat your state as **immutable**. That, and `connect` is pretty awesome.\n\n<guide>\nYou have read and understood the above\n</guide>"}</Action>
<Action name="Update Blocking and withRouter">{"That being said, `connect` and `shouldComponentUpdate` are the source of our `activeClassName` woes. Here's why:\n\nIn `ChannelList.js`, think about the props that we receive: messages and channels. Do either of these change when the url changes from `/channels/1` to `/channels/2`? No, they don't! Because the component doesn't receive any data that changes, the `connect` will be *too* smart and block re-rendering.\n\nNow, what data *does* change when the url changes? The answer is the route props that we get from React Router (`match`, `location` and `history`)! However, those props are only passed from `Route`s down to their `component`s, and `ChannelList` is not rendered by a `Route`.\n\nFortunately, React Router exposes a nice higher order function that we can use to pass down the the route props to any arbitrary component: [`withRouter`](https://reacttraining.com/react-router/web/api/withRouter). We can use this to pass the route props to `ChannelList` - `connect` will recognize the changing data, and re-render like normal.\n\n* Check out this article in the React Router docs about update blocking (and how to fix it): https://reacttraining.com/react-router/web/guides/dealing-with-update-blocking\n* Use `withRouter` fix our `activeClassName` bug\n\n<hint title=\"Solution\">\nIf we wrap our connected component in `withRouter`, the connected component will be aware when the router changes\n\n```js\nexport default withRouter(connect(mapStateToProps)(ChannelList));\n```\n</hint>\n\n<guide>\nThe activeClassName changes appropriately in the channel list again\n</guide>"}</Action>
<Action name="Combine Reducers">{"Something that might be bugging you is how big the `switch` statement within our `reducer` has gotten. It's bugging me too - fortunately, `redux` offers us a utility function that we can use to break up our one big reducer into many smaller \"sub-reducers\".\n\nIf you haven't yet (or even if you have), check out the [Redux docs for combineReducers](http://redux.js.org/docs/api/combineReducers.html)\n\nWhen you feel comfortable with what `combineReducers` does, move on and we'll use it to refactor our Redux code!\n\n<guide>\nYou have learned about combineReducers\n</guide>"}</Action>
<Action name="Breaking Up store.js">{"Now that we know how `combineReducers` works, let's refactor `store.js` so that instead of a single `store.js`, we have a `store/` directory that contains multiple sub-reducers, and combines them all in an `index.js`. You should have a sub-reducer for each slice of state.\n\nHere's what it might look like:\n\n<hint title=\"store directory\">\n```\nclient/\n  store/\n    channels.js\n    index.js\n    messages.js\n    name.js\n    newChannelEntry.js\n    newMessageEntry.js\n```\n</hint>\n\nIf you would like an example to get started, here's what `messages.js` and `index.js` might look like:\n\n<hint title=\"messages.js\">\n\nNote how in the sub-reducer, the `state` is actually the messages array itself! `combineReducers` does all the work of putting together our big \"state\" object together.\n\n<pre>\nimport axios from 'axios';\nimport socket from '../socket';\n\n// ACTION TYPES\n\nconst GET_MESSAGE = 'GET_MESSAGE';\nconst GET_MESSAGES = 'GET_MESSAGES';\n\n// ACTION CREATORS\n\nexport function getMessage (message) {\n  const action = { type: GET_MESSAGE, message };\n  return action;\n}\n\nexport function getMessages (messages) {\n  const action = { type: GET_MESSAGES, messages };\n  return action;\n}\n\n// THUNK CREATORS\n\nexport function fetchMessages () {\n\n  return function thunk (dispatch) {\n    return axios.get('/api/messages')\n      .then(res => res.data)\n      .then(messages => {\n        const action = getMessages(messages);\n        dispatch(action);\n      });\n  };\n}\n\nexport function postMessage (message) {\n\n  return function thunk (dispatch) {\n    return axios.post('/api/messages', message)\n      .then(res => res.data)\n      .then(newMessage => {\n        const action = getMessage(newMessage);\n        dispatch(action);\n        socket.emit('new-message', newMessage);\n      });\n  };\n}\n\n// REDUCER\n\nexport default function messagesReducer (state = [], action) {\n\n  switch (action.type) {\n\n    case GET_MESSAGES:\n      return action.messages;\n\n    case GET_MESSAGE:\n      return [...state, action.message];\n\n    default:\n      return state;\n  }\n\n}\n\n</pre>\n</hint>\n<hint title=\"index.js\">\n```js\nimport {\n  createStore,\n  applyMiddleware,\n  combineReducers\n} from 'redux';\nimport createLogger from 'redux-logger';\nimport thunkMiddleware from 'redux-thunk';\nimport { composeWithDevTools } from 'redux-devtools-extension';\n\n// import the messages sub-reducer\nimport messages from './messages';\n\nconst reducer = combineReducers({\n  messages\n});\n\nconst store = createStore(\n  reducer,\n  composeWithDevTools(applyMiddleware(\n    thunkMiddleware,\n    createLogger()\n  ))\n);\n\nexport default store;\n\n```\n</hint>\n\nTry the rest on your own!\n\nAlso, can you make it so that you don't need to refactor all of the files that use our action creators?\n\n<hint title=\"Approach\">\nDid you know that you can `export` the exports of another module?\n\nFor example, in `store/index.js`, if you say `export * from './messages'`, this will cause `index.js` to export all of the functions that `messages.js` exports! Whoa!\n\nFollowing the example above, this means `index.js` would look like:\n\n```js\nimport {\n  createStore,\n  applyMiddleware,\n  combineReducers\n} from 'redux';\nimport createLogger from 'redux-logger';\nimport thunkMiddleware from 'redux-thunk';\nimport { composeWithDevTools } from 'redux-devtools-extension';\n\n// import the messages sub-reducer\nimport messages from './messages';\n\nconst reducer = combineReducers({\n  messages\n});\n\nconst store = createStore(\n  reducer,\n  composeWithDevTools(applyMiddleware(\n    thunkMiddleware,\n    createLogger()\n  ))\n);\n\n// store is exported by default\nexport default store;\n\n// ...but we also export everything from messages!\nexport * from './messages';\n```\n</hint>"}</Action></Concept>
<Concept name="Bonus"><Action name="Refactor">{"Get some more practice using connect - refactor the other components that currently import the store directly, and make them use connect instead."}</Action>
<Action name="Channel Name in the Navbar">{"You've come so far! Try to accomplish the bonus goal of syncing up the channel name in the navbar. This could actually be a bit tricky! Consider this an extra challenge!"}</Action>
<Action name="Retro">{"Are there any bonus sections from StackChat part 1 that you didn't get to? Give them a go now!"}</Action></Concept>
<Concept name="Composability Cookbook"><Action name="Intro">{"The following sections are **not necessary** to complete this workshop.\n\nThey are bonus readings that go over several advanced concepts, and are meant to be a reference as you continue your React journey. You may wish to read them now, or at some point in the future. They contain some thoughts (*including some opinions*) on how to take advantage of React's functional architecture to write components that are modular and DRY.\n\nI hope you enjoy them and return to them every so often!"}</Action>
<Action name="Handling Localized State">{"There are several form components in Juke (for example, the `input` to filter artists, or the `select` used to add songs to playlists.\n\nWe learned about the distinction that some developers make between `local state` and `application state` in [Juke Part 3: Forms](https://learn.fullstackacademy.com/workshop/581352f6b659df00039f5189/content/5820a141c9884c0003daac3a/text). When we throw the `redux` store into the fray, this distinction can become much more acute. While the `redux` store, at its strictest, is meant to be the single source of truth for **all** of the state in your application (from the identity of the logged in user, down to the lowliest `input` element), some developers don't like the idea of \"polluting\" their redux store with something as localized as form data. \n\nThere are two schools of thought here:\n\n1. We might choose to keep all of our `application state` in our Redux store, and write components that need local state as stateful React components (and use `setState` to update them). The upside of this approach is that it feels nice to not have to \"clutter\" our Redux store with state that feels ephemeral. The downside is that, strictly speaking, we no longer have a single source of truth for **all** the state in our app - we must be careful to make sure that our local state really is just local!\n\n2. We might choose to be strict about keeping everything in our Redux store, and try to take advantage of the composability of reducers to work out a system that puts all of our local state in one place. For example, we might make a slice of state called \"forms\", and nest the local state for each form in our app there. The upside of this approach is that we don't lose any of the advantages that Redux has given us. The downside is that it requires more forethought and coordination. This is where libraries like [`redux-form`](http://redux-form.com/6.0.5/) come in - it introduces a reducer and several higher order components that tuck the state of our forms away in their own place.\n\nEither one of these is a perfectly fine choice. All that I would suggest you do is that you be **consistent** with which approach you choose. It would be far more confusing if only *some* of your form data was handled in your `redux` store and *some* was handled by local state in a React class."}</Action>
<Action name="Localized State: Example">{"Say that we want to take a combined approach where we keep local form data in a React component's state, and manage our application's data in our `redux` store. Here is how we might combine our three types of components. Consider the following simple form:\n\n**With no user submitted**\n<div>\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/58135430b659df00039f518f/no-duke.png\"/>\n</div>\n**After submitting a user**\n<div>\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/58135430b659df00039f518f/duke.png\"/>\n</div>\n\nIn this example, our `redux` store will hold the `user`, but the data in the field will be held by a stateful React component.\n\n1. A `connect` component written with `react-redux`, which exposes a way to `dispatch` changes to the `redux` store\n2. A stateful React class that manages local form data\n3. A stateless functional React component that displays the UI and connects event listeners\n\n**Container.js**\n```js\nimport { connect } from 'react-redux';\nimport { submitLoginActionCreator } from '../action-creators';\nimport StatefulFormClass from './StatefulFormClass';\n\nconst mapStateToProps = state => {\n  return {\n    // our main state.user\n    user: state.user\n  };\n};\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    // dispatches a change to our central `state.user` in the redux store\n    submitLogin (userName) {\n      dispatch(submitLoginActionCreator(userName));\n    }\n  };\n};\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(StatefulFormClass);\n```\n\n**StatefulFormClass.js**\n```js\nimport React, { Component } from 'react';\nimport StatelessForm from './StatelessForm';\n\nexport default class StatefulFormClass extends Component {\n  \n  constructor (props) {\n    super(props);\n    this.state = {\n      inputValue: '' // the entered user name\n    };\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n  \n  // updates our local state when the input form is changed\n  handleChange (evt) {\n    evt.preventDefault();\n    this.setState({\n      inputValue: evt.target.value\n    });\n  }\n \n  // takes our local inputValue and passes it to the method from our connect component, \n  // which has access to `dispatch`\n  handleSubmit (evt) {\n    evt.preventDefault();\n    this.props.submitLogin(this.state.inputValue);\n  }\n  \n  render () {\n    // passes down the local methods and inputValue, as well as the `user` from the store\n    return (\n      <StatelessForm \n        user={this.props.user}\n        inputValue={this.state.inputValue}\n        handleSubmit={this.handleSubmit}\n        handleChange={this.handleChange}\n      />  \n    );\n  }\n}\n```\n\n**StatelessForm.js**\n```js\nimport React, { Component } from 'react';\n\nexport default function (props) {\n  \n  // a prop from our redux store\n  const user = props.user; \n  \n  // props from our local stateful component\n  const inputValue = props.inputValue; \n  const handleChange = props.handleChange;\n  const handleSubmit = props.handleSubmit;\n  \n  return (\n    <div>\n    \n      { user ? <h3>You are already logged in: { user }</h3> : null }\n      \n      <form onSubmit={handleSubmit}>\n        <label htmlFor=\"username\">Enter your name</label>\n        <input value={inputValue} onChange={handleChange} />\n        <button type=\"submit\">Submit</button>\n      </form>\n      \n    </div>\n  );\n}\n```"}</Action>
<Action name="Higher Order Components">{"A higher order component is still the same in concept as a higher order function - it's still just a function that returns another function. The only difference is that the function that a higher order component returns is a React class. Higher order functions are key to `composing re-usable functionality`.\n\nAs a refresher, here's how we might use a higher order function to compose different pieces of functionality.\n\nHere's a piece of code we write fairly frequently:\n```js\naxios.get('/api/something').then(res => res.data)\n```\n\nLet's say we have a backend that contains `/api/puppies` and `/api/kittens`. We would like to be able to do something like this:\n```js\ngetPuppies().then(puppies => console.log(puppies))\ngetKittens().then(kittens => console.log(kittens));\n```\n\nWe *could* write each of these functions ourselves:\n```\nconst getPuppies = () =>\n  axios.get('/api/puppies').then(res => res.data);\n\nconst getKittens = () =>\n  axios.get('/api/kittens').then(res => res.data);\n```\n\nUgh, that was exhausting. We can do better - let's write a higher order function that will create arbitrary \"api getters\" for us.\n\n```js\nconst createApiGetter = (resourceName) => {\n  return () => {\n    return axios.get(`api/${resourceName}`).then(res => res.data);\n  }\n}\n```\n\n*Or, even cleaner:*\n```js\nconst createApiGetter = (resourceName) => () =>\n  axios.get(`api/${resourceName}`).then(res => res.data);\n```\n\nNow, if we want to create those API functions, all we need to say is this:\n```js\nconst getPuppies = createApiGetter('puppies');\nconst getKittens = createApiGetter('kittens');\n```\n\nAh, much better. It may look like an extra step when there are only puppies and kittens, but imagine if there were birds and turtles and hedgehogs and all sorts of resources we wanted to request.\n\nNow let's take a look a generalized higher order component - this same logic applies:\n\n```js\nimport React from 'react';\nimport ComponentA from './ComponentA';\nimport ComponentB from './ComponentB';\n\nconst higherOrderComponent = function (InnerComponent) {\n\n  return function (props) {\n    <div>\n      {/* some view we want to share */}\n      <InnerComponent />\n    </div>\n  }\n}\n\nconst ComposedComponentA = higherOrderComponent(ComponentA);\nconst ComposedComponentB = higherOrderComponent(ComponentB);\n```\n\nIn the next section, we'll look at a practical example."}</Action>
<Action name="Higher Order Components: Example">{"Consider the following simple (but modular) table component:\n\n```js\n// just an inline style\nconst boldStyle = { fontWeight: 700 };\n\nconst makeCell = (label) =>\n  <td key={label}>{ label }</td>\n\nconst makeRow = (row, headers) =>\n  <tr key={row.id}>{ headers.map(header => makeCell(row[header])) }</tr>\n\nconst Table = (props) => {\n\n  const headers = props.headers;\n  const rows = props.rows;\n\n  return (\n    <table>\n      <thead>\n        <tr style={bold}>\n        { headers.map(makeCell) }\n        </tr>\n      </thead>\n      <tbody>\n      { rows.map(row => makeRow(row, headers)) }\n      </tbody>\n    </table>\n  );\n}\n```\n\nWe could use this to spin up a little table with any arbitrary data:\n\n```js\nconst COL_HEADERS = [\"name\", \"breed\"]\n\nconst DOGS = [\n  {\n    name: 'Lexie',\n    breed: 'Goldendoodle',\n    id: 1\n  },\n  {\n    name: 'Cody',\n    breed: 'Pug',\n    id: 2\n  },\n  {\n    name: 'Ben',\n    breed: 'Pitbull?',\n    id: 3\n  }\n];\n\nReactDOM.render(\n  <Table rows={DOGS} headers={COL_HEADERS} />,\n  document.getElementById('app')\n);\n```\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/58135430b659df00039f518f/table.png\"/>\n\nIn our application, say that we sometimes want a table that looks just like the one we have above. But sometimes, we like to add a header to our components:\n\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/58135430b659df00039f518f/table-with-header.png\"/>\n\nAnd we like to add headers to all kinds of components - not just tables! We want these headers to all be consistent, too.\n\nWe could just tack an `<h3>` tag in wherever we need it, but that could potentially lead to inconsistencies, and if we wanted to change the `<h3>` to an `<h2>` or something like that, we'd need to hunt them down everywhere. Instead, we could compose a component that will render the table with an arbitrary header. \n\n```js\nconst mixinTitle = (InnerComponent) => {\n  return (props) => {\n    const { title  } = props;\n\n      return (\n        <div>\n          <h3>{ title }</h3>\n          <InnerComponent {...props} />\n        </div>\n      );\n  }\n}\n```\n\nNow look how easy our life is:\n\n```js\nconst TableWithTitle = mixinTitle(Table);\n\nReactDOM.render(\n  <TitleTable title=\"Dogs\" rows={DOGS} headers={COL_HEADERS} />,\n  document.getElementById('app')\n);\n```\n\nWhat's great about this is that we can now add the same header to any component. All we need to do is compose it with the `mixinTitle` function and pass it the additional `title` prop:\n\n```js\n// consider this additional, simple component\nconst Greeting = (props) => {\n  return <p>{ props.message }</p>\n}\n\nconst TableWithTitle = mixinTitle(Table);\nconst ParagraphWithTitle = mixinTitle(Greeting);\n\nReactDOM.render(\n  <div>\n    <TitleTable title=\"Dogs\" rows={DOGS} headers={COL_HEADERS} />\n    <ParagraphWithTitle title=\"Greeting\" message=\"Hello world\" />\n  </div>,\n  document.getElementById('app')\n);\n```\n\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/58135430b659df00039f518f/table%20and%20p.png\"/>"}</Action>
<Action name="Higher Order Classes">{"As you may have inferred from the previous section, it is also possible to compose higher order components that return React classes (including classes that manage **state**) rather than just stateless components:\n\n```js\nimport React from 'react';\n\nconst statefulMixin = function (InnerComponent) {\n  return class StatefulWrapper extends React.Component {\n    constructor (props) {\n      super(props);\n      this.state = {/** a higher order component frequently manages local state */}\n      this.handleSomething = this.handleSomething.bind(this); // if this being passed to an event handler\n    }\n\n    handleSomething () {/** this might set our local state **/}\n\n    render () {\n    /** Remember our separation of concerns between stateful and presentational components.\n        The higher order component's render function should only return the inner component\n        decorated with any props the higher order component received and any state/behavior\n        that it's managing. */\n      return (\n        <InnerComponent\n          handleSomething={this.handleSomething}\n          {...this.props}\n          {...this.state}\n        />\n      )\n    }\n  }\n}\n```\n\nThis is extremely powerful - this allows us to compose state and behavior rather than just presentational features. In the next section, we'll see how this can simplify the way we deal with form data."}</Action>
<Action name="Higher Order Classes: Example">{"Say that we have various form elements of various types, like the following:\n\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/58135430b659df00039f518f/valid%20entry.png\"/>\n\nThese may just be small, versatile React components like these:\n\n```js\nconst Input = (props) => {\n  const { handleChange, value } = props;\n  return <input type=\"text\" value={value} onChange={handleChange} />\n};\n\nconst Select = (props) => {\n  const { handleChange, value } = props;\n  return (\n    <select value={value} onChange={handleChange}>\n      <option value=\"puppies\">Hug Puppies</option>\n      <option value=\"kittens\">Pet Kittens</option>\n      <option value=\"annihilation\">FIRE ZEE MISSILES!</option>\n    </select>\n  );\n};\n```\n\nNow, we want to show an arbitrary warning message whenever an arbitrary condition has been met.\n<img src=\"https://learndotresources.s3.amazonaws.com/workshop/58135430b659df00039f518f/warning%20entry.png\"/>\n\nWe could write two separate stateful components that perform this validation (one that renders the `Input` and one that renders the `Select`). But let's think in terms of composition: these two form elements share the same behavior. The only differences between them are:\n\n1. How we determine when the current value is invalid\n2. What message to show when the current value is invalid\n\nIf we imagine what this might look like as a React element, we might come up with this sort of interface:\n\n```js\n{/*\n  `warningMessage` would just be a string with the custom message\n\n  `validate` would be a function that accepts the value in the form, and returns true if we SHOULD show a warning,\n  and false if we SHOULD NOT show a warning\n*/}\n<InputOrSelect warningMessage={\"\"} validate={(formValue) => {}} />\n```\n\nWe have a good idea at this point how we would manage this functionality using local React state, but instead of writing separate classes to manage it, let's write a function that will return a class to manage that state/behavior instead:\n\n```js\nconst validateMixin = (InnerComponent) => {\n\n  const red = { color: 'red' }; // just an inline style\n\n  return class extends Component {\n\n    constructor (props) {\n      super(props);\n      this.state = {\n        value: '',\n        showWarning: false\n      };\n      this.handleChange = this.handleChange.bind(this);\n    }\n\n    handleChange (evt) {\n      const value = evt.target.value;\n      const { validate } = this.props;\n\n      this.setState({\n        value,\n        showWarning: validate(value)\n      });\n    }\n\n    render () {\n      const { showWarning } = this.state;\n      const { warningMessage } = this.props;\n\n      return (\n        <div>\n          { showWarning && <p style={red}>{ warningMessage }</p> }\n          <InnerComponent {...this.state} {...this.props} handleChange={this.handleChange} />\n        </div>\n      );\n    }\n  }\n}\n```\n\nNow, whenever we want one of our form elements to have this warning behavior, we simply mix the form's component into the class. All we need to do is define the warning message, and the criteria for showing the warning:\n\n```js\nconst Input = (props) => {\n  const { handleChange, value } = props;\n  return <input type=\"text\" value={value} onChange={handleChange} />\n};\n\nconst Select = (props) => {\n  const { handleChange, value } = props;\n  return (\n    <select value={value} onChange={handleChange}>\n      <option value=\"puppies\">Hug Puppies</option>\n      <option value=\"kittens\">Pet Kittens</option>\n      <option value=\"annihilation\">FIRE ZEE MISSILES!</option>\n    </select>\n  );\n};\n\nconst WarnableInput = validateMixin(Input);\n// validate if the input is too long\nconst validateInput = (inputString) => inputString.length > 16;\n\nconst WarnableSelect = validateMixin(Select);\n// validate if we choose to destroy humanity\nconst validateSelect = (selected) => selected === 'annihilation';\n```\n\nNow look how easy we have it:\n\n```js\nReactDOM.render(\n  <div>\n    <WarnableInput warningMessage=\"This is too long\" validate={validateInput} />\n    <WarnableSelect warningMessage=\"Maybe this is a bad idea?\" validate={validateSelect} />\n  </div>,\n  document.getElementById('app')\n);\n```"}</Action>
<Action name="Self Documentation">{"You've heard it before - good code should be `self-documenting`. This means that the names you choose should read like human language, and make semantic sense for the thing you're trying to do. When it comes to writing functions, this applies not only to the name that you give the function, but also to the name you give the arguments. Consider the following horrible function:\n\n```js\nfunction doAThing () {\n  const args = Array.prototype.slice.call(arguments);\n  if (!args[0].length) return false;\n  else return args[1](args[0]);\n}\n```\n\nUgh. We have no idea how to use this function. We need to read through the entire function's body to figure out what arguments it takes, if any, and it's not even clear what data types the function is expecting for those arguments.\n\nLet's improve our lives a bit:\n```js\nfunction doAThing (someString, callbackFunc) {\n  if (!someString.length) return false;\n  else return callbackFunc(someString);\n} \n```\n\nOkay, this is better. We know without having to walk through the function's body that it expect to receive a string as the first argument, and a function as the second argument. It takes way less brain power to realize that this function returns false if the string has no length, and otherwise returns the result of invoking the callback function with the string. It's still a contrived, nonsense function but you get the picture.\n\nReact components are just functions, and the same rules apply. The challenging thing is that React components only accept an object called \"props\" as an argument, and this can make learning how to use a particular component just as hard as it was to learn how the function above worked.\n\n\n**Quick:** what props does this component need to work?\n```js\nfunction MyComponent (props) {\n  return (\n    <div className=\"container\">\n      <label>{props.label}</label>\n      <input value={props.value} onChange={props.handleChange} />\n      <div className=\"form-control\">\n        <button className={props.buttonClassName}>Click Me</button>\n      </div>\n    </div>\n  );\n}\n```\n\nThat wasn't very fun, was it? In the `Juke` workshops, you've probably encountered the following pattern (which avails itself of `destructured assignment`). \n\n```js\nfunction MyComponent (props) {\n  const { label, value, handleChange, buttonClassName } = props;\n\n  return (\n    <div className=\"container\">\n      <label>{label}</label>\n      <input value={value} onChange={handleChange} />\n      <div className=\"form-control\">\n        <button className={buttonClassName}>Click Me</button>\n      </div>\n    </div>\n  );\n}\n```\n\nThis is way better. Not only does it clean up the namespace within JSX, but it also **clearly defines what props the component expects**. To learn how to use this component, you don't need to read much further than the first line to figure out what it takes for it to work.\n\nWe can do even better, too. We can destructure objects **in the function's definition** as well.\n\n\nFor example, here's a function that expects a config object:\n```js\nfunction configureApplication (configObj) {\n  // uses configObj.lovesPuppies and configObj.lovesKittens\n}\n```\n\nIf we want to pass an object in as an argument, it would be helpful to know what fields the function is going to use. That function can be written to **destructure** the key-value pairs it wants to use directly into the scope of the function:\n\n```js\nfunction configureApplication ({ lovesPuppies, lovesKittens }) {\n  // uses lovesPuppies and lovesKittens directly\n}\n```\n\nThis function still expects to receive an object, but it makes it perfectly clear that it's expecting an object with keys for \"lovesPuppies\" and/or \"lovesKittens\".\n\nLet's use this technique to perfect our component from before:\n\n```js\nfunction MyComponent ({ label, value, handleChange, buttonClassName }) {\n  return (\n    <div className=\"container\">\n      <label>{label}</label>\n      <input value={value} onChange={handleChange} />\n      <div className=\"form-control\">\n        <button className={buttonClassName}>Click Me</button>\n      </div>\n    </div>\n  );\n}\n```\n\nNow not only is our namespace clear, but our eyes don't even need to enter the function now - we can tell exactly what props it expects in the declaration. If you're not used to the syntax, it may take some initial getting used to, but after that you'll want all of your stateless components to be written this way!\n\nNote that we can only avail ourselves of this readability when we use stateless functional components, which is yet another reason why you should use them over classes whenever possible. (And of course don't forget **Tom's Second Law** by keeping them as dumb as can be!)"}</Action></Concept>
<Concept name="Outro"><Action name="Final Thoughts">{"Engineering front-ends for applications in a way that's stable, scalable and maintainable is an extremely difficult task. This is because user interfaces, unlike (for example) RESTful web services, are inherently `stateful`, and managing state is hard.\n\n`react` can be intimidating at first because it implements features of the functional programming paradigm (like `immutability` and `pure functions`) that allow you to reason about your UI as easily as you reason about functions: `render(state) => view`. That's all there is to it.\n\nThe tools you've learned to use throughout `StackChat` and `Juke` will help you write killer web applications, but you've also learned something bigger: the fundamentals of functional programming, and how to manage state to be predictable. You'll encounter many programs and even programming languages throughout your career that are stuck relying on procedural, imperative and object-oriented ways of thinking. The functional paradigm is powerful, and will serve you well for your entire career."}</Action>
<Action name="Resources">{"This section will undoubtedly grow… have any suggestions? Let us know!\n\n* http://slides.com/jenyaterpil/redux-from-twitter-hype-to-production#/"}</Action></Concept></Workshop>
